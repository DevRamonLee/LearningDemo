## 第 1 阶段：音视频编解码 & 推拉流

### 📸 `01_capture_encode/`

**🎯 学习目标：**
- 熟悉 V4L2 获取摄像头数据流程
- 掌握 FFmpeg API 使用（AVFormat, AVCodec）
- 理解 YUV → H.264/H.265 编码流程

**🛠 实践任务：**

- 编写程序：采集摄像头 → 编码成 H.264/H.265 → 输出文件
- 支持分辨率/帧率参数配置

---

### 📦 `02_mux_record/`

**🎯 学习目标：**

- 掌握 FFmpeg 封装格式（MP4/FLV）处理
- 理解编码数据如何封装到容器中

**🛠 实践任务：**

- 将编码后的 H.264 通过 FFmpeg 封装为 MP4/FLV
- 实现按时间或大小分段录制功能

---

### 🌐 `03_push_rtmp/`

**🎯 学习目标：**

- 理解 RTMP 协议原理及推流流程
- 掌握 FFmpeg 推流命令/API
- 搭建 nginx-rtmp 本地测试环境

**🛠 实践任务：**

- 使用 FFmpeg 将摄像头采集内容推送至本地 RTMP Server
- 搭建 nginx-rtmp，支持局域网播放

---

### 📥 `04_pull_play_rtsp/`

**🎯 学习目标：**

- 学会用 FFmpeg/live555 接收 RTSP 流
- 掌握解码 + 播放流程（SDL/ffplay）

**🛠 实践任务：**

- 拉取公开或本地 RTSP 视频流
- 解码播放或存储为本地视频

---

### 🛰️ `05_webrtc_stream/`

**🎯 学习目标：**

- WebRTC 架构理解（ICE/STUN/DTLS）
- 掌握 GStreamer WebRTC 管道构建方式
- 能与浏览器互通（推/拉）

**🛠 实践任务：**

- 搭建基于 Janus/GStreamer 的 WebRTC Demo
- 实现摄像头推 WebRTC → 浏览器播放

---

## ✅ 第 2 阶段：Linux 应用通信层

### 🔗 `06_net_socket/`

**🎯 学习目标：**

- 熟悉 TCP/UDP C/S 编程模型
- 掌握 epoll/多线程处理多个连接

**🛠 实践任务：**

- 编写 TCP 服务端 + 多客户端通信系统
- 实现简单命令控制协议（例如“开始推流”、“停止录制”等）

---

### 🧃 `07_can_protocol/`

**🎯 学习目标：**

- 掌握 SocketCAN 基本用法
- 理解 CAN 报文结构（ID/数据域）

**🛠 实践任务：**

- 模拟发送/接收 ECU 报文（虚拟 CAN）
- 实现 CAN 报文解析、事件触发机制（例如报警命令）

---

### 🚦 `08_traffic_protocol/`

**🎯 学习目标：**

- 理解视频平台协议（如 GB28181）结构
- 熟悉 SIP/SDP 信令基本概念
- 掌握如何实现自定义控制协议

**🛠 实践任务：**

- 编写解析模块处理平台命令（如查询状态、控制播放）
- 支持简单 SIP 注册/会话模拟或自定义 JSON 控制协议

---

## ✅ 第 3 阶段：综合集成

### 🧩 `09_full_integration/`

**🎯 学习目标：**

- 掌握控制流（Socket/CAN）+ 数据流（音视频）集成设计
- 理解模块化架构与异步通信

**🛠 实践任务：**

- 综合实现：
    - 摄像头采集 → 编码 → 推 RTMP/WebRTC
    - 支持命令控制（Socket）：开始/停止/切换流
    - CAN 报文控制推流状态或触发报警音视频
- 输出最终 Demo：如“智能车载终端”模拟系统